{
  "prisma": {
    "migrations": {
      "20241104195854_init": {
        "migration.sql": "-- CreateTable\nCREATE TABLE \"technology\" (\n    \"id\" SERIAL NOT NULL,\n    \"name\" TEXT NOT NULL,\n    \"description\" TEXT NOT NULL,\n    \"tags\" TEXT[],\n    \"created_at\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"updated_at\" TIMESTAMP(3) NOT NULL,\n\n    CONSTRAINT \"technology_pkey\" PRIMARY KEY (\"id\")\n);\n\n-- CreateTable\nCREATE TABLE \"question\" (\n    \"id\" SERIAL NOT NULL,\n    \"question\" TEXT NOT NULL,\n    \"answer\" TEXT NOT NULL,\n    \"created_at\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"updated_at\" TIMESTAMP(3) NOT NULL,\n    \"technology_id\" INTEGER NOT NULL,\n\n    CONSTRAINT \"question_pkey\" PRIMARY KEY (\"id\")\n);\n\n-- CreateTable\nCREATE TABLE \"resource\" (\n    \"id\" SERIAL NOT NULL,\n    \"title\" TEXT NOT NULL,\n    \"url\" TEXT NOT NULL,\n    \"created_at\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"updated_at\" TIMESTAMP(3) NOT NULL,\n    \"technology_id\" INTEGER NOT NULL,\n\n    CONSTRAINT \"resource_pkey\" PRIMARY KEY (\"id\")\n);\n\n-- CreateTable\nCREATE TABLE \"project\" (\n    \"id\" SERIAL NOT NULL,\n    \"name\" TEXT NOT NULL,\n    \"description\" TEXT NOT NULL,\n    \"created_at\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"updated_at\" TIMESTAMP(3) NOT NULL,\n\n    CONSTRAINT \"project_pkey\" PRIMARY KEY (\"id\")\n);\n\n-- CreateTable\nCREATE TABLE \"_ProjectTechnology\" (\n    \"A\" INTEGER NOT NULL,\n    \"B\" INTEGER NOT NULL\n);\n\n-- CreateIndex\nCREATE UNIQUE INDEX \"technology_name_key\" ON \"technology\"(\"name\");\n\n-- CreateIndex\nCREATE UNIQUE INDEX \"project_name_key\" ON \"project\"(\"name\");\n\n-- CreateIndex\nCREATE UNIQUE INDEX \"_ProjectTechnology_AB_unique\" ON \"_ProjectTechnology\"(\"A\", \"B\");\n\n-- CreateIndex\nCREATE INDEX \"_ProjectTechnology_B_index\" ON \"_ProjectTechnology\"(\"B\");\n\n-- AddForeignKey\nALTER TABLE \"question\" ADD CONSTRAINT \"question_technology_id_fkey\" FOREIGN KEY (\"technology_id\") REFERENCES \"technology\"(\"id\") ON DELETE RESTRICT ON UPDATE CASCADE;\n\n-- AddForeignKey\nALTER TABLE \"resource\" ADD CONSTRAINT \"resource_technology_id_fkey\" FOREIGN KEY (\"technology_id\") REFERENCES \"technology\"(\"id\") ON DELETE RESTRICT ON UPDATE CASCADE;\n\n-- AddForeignKey\nALTER TABLE \"_ProjectTechnology\" ADD CONSTRAINT \"_ProjectTechnology_A_fkey\" FOREIGN KEY (\"A\") REFERENCES \"project\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\n\n-- AddForeignKey\nALTER TABLE \"_ProjectTechnology\" ADD CONSTRAINT \"_ProjectTechnology_B_fkey\" FOREIGN KEY (\"B\") REFERENCES \"technology\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\n"
      },
      "migration_lock.toml": "# Please do not edit this file manually\n# It should be added in your version-control system (i.e. Git)\nprovider = \"postgresql\""
    },
    "schema.prisma": "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?\n// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Technology {\n  id          Int        @id @default(autoincrement())\n  name        String     @unique\n  description String\n  tags        String[]\n  createdAt   DateTime   @default(now()) @map(\"created_at\")\n  updatedAt   DateTime   @updatedAt @map(\"updated_at\")\n  questions   Question[]\n  resources   Resource[]\n  projects    Project[]  @relation(\"ProjectTechnology\")\n\n  @@map(\"technology\")\n}\n\nmodel Question {\n  id           Int        @id @default(autoincrement())\n  question     String\n  answer       String\n  createdAt    DateTime   @default(now()) @map(\"created_at\")\n  updatedAt    DateTime   @updatedAt @map(\"updated_at\")\n  technology   Technology @relation(fields: [technologyId], references: [id])\n  technologyId Int        @map(\"technology_id\")\n\n  @@map(\"question\")\n}\n\nmodel Resource {\n  id           Int        @id @default(autoincrement())\n  title        String\n  url          String\n  createdAt    DateTime   @default(now()) @map(\"created_at\")\n  updatedAt    DateTime   @updatedAt @map(\"updated_at\")\n  technology   Technology @relation(fields: [technologyId], references: [id])\n  technologyId Int        @map(\"technology_id\")\n\n  @@map(\"resource\")\n}\n\nmodel Project {\n  id           Int          @id @default(autoincrement())\n  name         String       @unique\n  description  String\n  createdAt    DateTime     @default(now()) @map(\"created_at\")\n  updatedAt    DateTime     @updatedAt @map(\"updated_at\")\n  technologies Technology[] @relation(\"ProjectTechnology\")\n\n  @@map(\"project\")\n}"
  },
  "src": {
    "app.module.ts": "import { Module } from '@nestjs/common';\nimport { ProjectsModule } from './projects/projects.module';\nimport { QuestionsModule } from './questions/questions.module';\nimport { ResourcesModule } from './resources/resources.module';\nimport { TechnologiesModule } from './technologies/technologies.module';\nimport { PrismaModule } from './prisma/prisma.module';\nimport { ConfigModule } from '@nestjs/config';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      //Permite acceder a los modulos en toda la aplicación\n      isGlobal: true,\n    }),\n    ProjectsModule,\n    QuestionsModule,\n    ResourcesModule,\n    TechnologiesModule,\n    PrismaModule,\n  ],\n  controllers: [],\n  providers: [],\n})\nexport class AppModule {}\n",
    "main.ts": "import { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { ValidationPipe } from '@nestjs/common';\n\n//boostrap se encarga de inicializar toda la aplicación de NestJS\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  //Validación de entrada de datos global\n  app.useGlobalPipes(\n    new ValidationPipe({\n      whitelist: true, //Aseguramos que solo sean permitidas propiedades dentro de las DTO\n      forbidNonWhitelisted: true, //Rechaza cualquier propiedad no permitida\n      transform: true, //Transforma los datos recibidos a los tipos apropiados de las clases DTO\n    }),\n  );\n  //Inicializa la aplicación\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();\n",
    "prisma": {
      "prisma.module.ts": "import { Module, Global } from '@nestjs/common';\nimport { PrismaService } from './prisma.service';\n\n//Modulo global para utilizar en toda la aplicación\n@Global()\n@Module({\n  providers: [PrismaService],\n  exports: [PrismaService],\n})\nexport class PrismaModule {}\n",
      "prisma.service.ts": "//Conexión con la base de datos.\nimport { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';\nimport { PrismaClient } from '@prisma/client';\n\n@Injectable()\nexport class PrismaService extends PrismaClient implements OnModuleInit {\n  //Conecta a la db\n  async onModuleInit() {\n    await this.$connect();\n  }\n  //Desconecta a la db\n  async OnModuleDestroy() {\n    await this.$disconnect();\n  }\n}\n"
    },
    "projects": {
      "dto": {
        "create-project.dto.ts": "export class CreateProjectDto {}\n",
        "update-project.dto.ts": "import { PartialType } from '@nestjs/mapped-types';\nimport { CreateProjectDto } from './create-project.dto';\n\nexport class UpdateProjectDto extends PartialType(CreateProjectDto) {}\n"
      },
      "entities": {
        "project.entity.ts": "export class Project {}\n"
      },
      "projects.controller.ts": "import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';\nimport { ProjectsService } from './projects.service';\nimport { CreateProjectDto } from './dto/create-project.dto';\nimport { UpdateProjectDto } from './dto/update-project.dto';\n\n@Controller('projects')\nexport class ProjectsController {\n  constructor(private readonly projectsService: ProjectsService) {}\n\n  @Post()\n  create(@Body() createProjectDto: CreateProjectDto) {\n    return this.projectsService.create(createProjectDto);\n  }\n\n  @Get()\n  findAll() {\n    return this.projectsService.findAll();\n  }\n\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    return this.projectsService.findOne(+id);\n  }\n\n  @Patch(':id')\n  update(@Param('id') id: string, @Body() updateProjectDto: UpdateProjectDto) {\n    return this.projectsService.update(+id, updateProjectDto);\n  }\n\n  @Delete(':id')\n  remove(@Param('id') id: string) {\n    return this.projectsService.remove(+id);\n  }\n}\n",
      "projects.module.ts": "import { Module } from '@nestjs/common';\nimport { ProjectsService } from './projects.service';\nimport { ProjectsController } from './projects.controller';\n\n@Module({\n  controllers: [ProjectsController],\n  providers: [ProjectsService],\n})\nexport class ProjectsModule {}\n",
      "projects.service.ts": "import { Injectable } from '@nestjs/common';\nimport { CreateProjectDto } from './dto/create-project.dto';\nimport { UpdateProjectDto } from './dto/update-project.dto';\n\n@Injectable()\nexport class ProjectsService {\n  create(createProjectDto: CreateProjectDto) {\n    return 'This action adds a new project';\n  }\n\n  findAll() {\n    return `This action returns all projects`;\n  }\n\n  findOne(id: number) {\n    return `This action returns a #${id} project`;\n  }\n\n  update(id: number, updateProjectDto: UpdateProjectDto) {\n    return `This action updates a #${id} project`;\n  }\n\n  remove(id: number) {\n    return `This action removes a #${id} project`;\n  }\n}\n"
    },
    "questions": {
      "dto": {
        "create-question.dto.ts": "export class CreateQuestionDto {}\n",
        "update-question.dto.ts": "import { PartialType } from '@nestjs/mapped-types';\nimport { CreateQuestionDto } from './create-question.dto';\n\nexport class UpdateQuestionDto extends PartialType(CreateQuestionDto) {}\n"
      },
      "entities": {
        "question.entity.ts": "export class Question {}\n"
      },
      "questions.controller.ts": "import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';\nimport { QuestionsService } from './questions.service';\nimport { CreateQuestionDto } from './dto/create-question.dto';\nimport { UpdateQuestionDto } from './dto/update-question.dto';\n\n@Controller('questions')\nexport class QuestionsController {\n  constructor(private readonly questionsService: QuestionsService) {}\n\n  @Post()\n  create(@Body() createQuestionDto: CreateQuestionDto) {\n    return this.questionsService.create(createQuestionDto);\n  }\n\n  @Get()\n  findAll() {\n    return this.questionsService.findAll();\n  }\n\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    return this.questionsService.findOne(+id);\n  }\n\n  @Patch(':id')\n  update(@Param('id') id: string, @Body() updateQuestionDto: UpdateQuestionDto) {\n    return this.questionsService.update(+id, updateQuestionDto);\n  }\n\n  @Delete(':id')\n  remove(@Param('id') id: string) {\n    return this.questionsService.remove(+id);\n  }\n}\n",
      "questions.module.ts": "import { Module } from '@nestjs/common';\nimport { QuestionsService } from './questions.service';\nimport { QuestionsController } from './questions.controller';\n\n@Module({\n  controllers: [QuestionsController],\n  providers: [QuestionsService],\n})\nexport class QuestionsModule {}\n",
      "questions.service.ts": "import { Injectable } from '@nestjs/common';\nimport { CreateQuestionDto } from './dto/create-question.dto';\nimport { UpdateQuestionDto } from './dto/update-question.dto';\n\n@Injectable()\nexport class QuestionsService {\n  create(createQuestionDto: CreateQuestionDto) {\n    return 'This action adds a new question';\n  }\n\n  findAll() {\n    return `This action returns all questions`;\n  }\n\n  findOne(id: number) {\n    return `This action returns a #${id} question`;\n  }\n\n  update(id: number, updateQuestionDto: UpdateQuestionDto) {\n    return `This action updates a #${id} question`;\n  }\n\n  remove(id: number) {\n    return `This action removes a #${id} question`;\n  }\n}\n"
    },
    "resources": {
      "dto": {
        "create-resource.dto.ts": "export class CreateResourceDto {}\n",
        "update-resource.dto.ts": "import { PartialType } from '@nestjs/mapped-types';\nimport { CreateResourceDto } from './create-resource.dto';\n\nexport class UpdateResourceDto extends PartialType(CreateResourceDto) {}\n"
      },
      "entities": {
        "resource.entity.ts": "export class Resource {}\n"
      },
      "resources.controller.ts": "import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';\nimport { ResourcesService } from './resources.service';\nimport { CreateResourceDto } from './dto/create-resource.dto';\nimport { UpdateResourceDto } from './dto/update-resource.dto';\n\n@Controller('resources')\nexport class ResourcesController {\n  constructor(private readonly resourcesService: ResourcesService) {}\n\n  @Post()\n  create(@Body() createResourceDto: CreateResourceDto) {\n    return this.resourcesService.create(createResourceDto);\n  }\n\n  @Get()\n  findAll() {\n    return this.resourcesService.findAll();\n  }\n\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    return this.resourcesService.findOne(+id);\n  }\n\n  @Patch(':id')\n  update(@Param('id') id: string, @Body() updateResourceDto: UpdateResourceDto) {\n    return this.resourcesService.update(+id, updateResourceDto);\n  }\n\n  @Delete(':id')\n  remove(@Param('id') id: string) {\n    return this.resourcesService.remove(+id);\n  }\n}\n",
      "resources.module.ts": "import { Module } from '@nestjs/common';\nimport { ResourcesService } from './resources.service';\nimport { ResourcesController } from './resources.controller';\n\n@Module({\n  controllers: [ResourcesController],\n  providers: [ResourcesService],\n})\nexport class ResourcesModule {}\n",
      "resources.service.ts": "import { Injectable } from '@nestjs/common';\nimport { CreateResourceDto } from './dto/create-resource.dto';\nimport { UpdateResourceDto } from './dto/update-resource.dto';\n\n@Injectable()\nexport class ResourcesService {\n  create(createResourceDto: CreateResourceDto) {\n    return 'This action adds a new resource';\n  }\n\n  findAll() {\n    return `This action returns all resources`;\n  }\n\n  findOne(id: number) {\n    return `This action returns a #${id} resource`;\n  }\n\n  update(id: number, updateResourceDto: UpdateResourceDto) {\n    return `This action updates a #${id} resource`;\n  }\n\n  remove(id: number) {\n    return `This action removes a #${id} resource`;\n  }\n}\n"
    },
    "technologies": {
      "dto": {
        "create-technology.dto.ts": "//Importamos todas las validaciones a utilizar\nimport {\n  IsString,\n  IsArray,\n  IsNotEmpty,\n  MinLength,\n  MaxLength,\n  ArrayMinSize,\n} from 'class-validator';\n\n//Al crear una tecnología utilizara las siguientes validaciones para cada propiedad:\nexport class CreateTechnologyDto {\n  @IsString()\n  @IsNotEmpty()\n  @MinLength(3)\n  @MaxLength(50)\n  name: string;\n\n  @IsString()\n  @IsNotEmpty()\n  @MinLength(3)\n  @MaxLength(50)\n  description: string;\n\n  @IsArray()\n  @ArrayMinSize(1)\n  tags: string[];\n\n  @IsArray()\n  @IsString({ each: true }) //Cada elemento del arreglo va a ser string\n  @IsNotEmpty({ each: true }) //Que ningun elemento este vacio\n  projects?: string[];\n}\n",
        "update-technology.dto.ts": "import { PartialType } from '@nestjs/mapped-types';\nimport { CreateTechnologyDto } from './create-technology.dto';\n\nexport class UpdateTechnologyDto extends PartialType(CreateTechnologyDto) {}\n"
      },
      "entities": {
        "technology.entity.ts": "export class Technology {}\n"
      },
      "technologies.controller.ts": "import {\n  Controller,\n  Get,\n  Post,\n  Body,\n  Patch,\n  Param,\n  Delete,\n  Query,\n} from '@nestjs/common';\nimport { TechnologiesService } from './technologies.service';\nimport { CreateTechnologyDto } from './dto/create-technology.dto';\nimport { UpdateTechnologyDto } from './dto/update-technology.dto';\n\n@Controller('technologies')\nexport class TechnologiesController {\n  constructor(private readonly technologiesService: TechnologiesService) {}\n\n  @Post()\n  create(@Body() createTechnologyDto: CreateTechnologyDto) {\n    return this.technologiesService.create(createTechnologyDto);\n  }\n\n  @Get()\n  findAll(\n    @Query('tag') tag?: string,\n    @Query('search') search?: string,\n    @Query('project') project?: string,\n    @Query('orderBy') orderBy?: 'name' | 'createdAt',\n    @Query('order') order?: 'asc' | 'desc',\n  ) {\n    return this.technologiesService.findAll({\n      tag,\n      search,\n      project,\n      order,\n      orderBy,\n    });\n  }\n\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    return this.technologiesService.findOne(+id);\n  }\n\n  @Patch(':id')\n  update(\n    @Param('id') id: string,\n    @Body() updateTechnologyDto: UpdateTechnologyDto,\n  ) {\n    return this.technologiesService.update(+id, updateTechnologyDto);\n  }\n\n  @Delete(':id')\n  remove(@Param('id') id: string) {\n    return this.technologiesService.remove(+id);\n  }\n}\n",
      "technologies.module.ts": "import { Module } from '@nestjs/common';\nimport { TechnologiesService } from './technologies.service';\nimport { TechnologiesController } from './technologies.controller';\nimport { PrismaClient } from '@prisma/client';\n\n@Module({\n  imports: [PrismaClient],\n  controllers: [TechnologiesController],\n  providers: [TechnologiesService],\n})\nexport class TechnologiesModule {}\n",
      "technologies.service.ts": "import { HttpException, Injectable } from '@nestjs/common';\nimport { CreateTechnologyDto } from './dto/create-technology.dto';\nimport { UpdateTechnologyDto } from './dto/update-technology.dto';\nimport { PrismaService } from 'src/prisma/prisma.service';\nimport { Prisma, Technology } from '@prisma/client';\n\n@Injectable()\nexport class TechnologiesService {\n  //Conectamos a prismaService nuestro constructor\n  constructor(private readonly prisma: PrismaService) {}\n  //Metodo asincronico para crear una nueva tecnología\n  async create(createTechnologyDto: CreateTechnologyDto) {\n    //Desestructuramos el proyecto por un lado y los datos de la tecnología a crear por otro.\n    const { projects, ...technologyData } = createTechnologyDto;\n    //Comprobamos que la tecnología existe\n    const existing = await this.prisma.technology.findUnique({\n      where: {\n        name: technologyData.name,\n      },\n    });\n    //Si existe entonces lanzamos un error\n    if (existing) {\n      throw new HttpException('Technology already exists', 400);\n    }\n    //En caso de que no exista, creamos la nueva tecnología\n    try {\n      const technology = await this.prisma.technology.create({\n        data: {\n          ...technologyData,\n          //Los proyectos son una tabla aparte por lo tanto se conecta de la siguiente manera:\n          projects: {\n            connect: projects?.map((project) => ({ name: project })),\n          },\n        },\n      });\n      return technology;\n    } catch (e) {\n      throw new HttpException(`${e} Error creating technology`, 500);\n    }\n  }\n\n  async findAll(params: {\n    //Metodo asincronico que recibe parametros opcionales\n    tag?: string;\n    search?: string;\n    project?: string;\n    //Paginación y ordenamiento\n    skip?: number;\n    take?: number;\n    orderBy?: 'name' | 'createdAt';\n    order?: 'asc' | 'desc';\n  }): Promise<{ technologies: Technology[]; total: number }> {\n    //Desestructuramos los parametros\n    const {\n      tag,\n      search,\n      project,\n      //Skip y take reciben un valor por defecto\n      skip = 0,\n      take = 10,\n      orderBy = 'createdAt',\n      order = 'desc',\n    } = params;\n\n    const where: Prisma.TechnologyWhereInput = {};\n    //Si hay tag, busca tecnologías que contengan ese tag\n    if (tag) {\n      where.tags = {\n        has: tag, //Indicamos que el tag que recibo por parametro es el que buscamos en la db\n      };\n    }\n    /* Filtra por busqueda\n    Si hay término de búsqueda, busca en:\n    Nombre (insensible a mayúsculas/minúsculas)\n    Descripción (insensible a mayúsculas/minúsculas)\n    Tags */\n    if (search) {\n      where.OR = [\n        //Puede contener nombre, description o tag\n        { name: { contains: search, mode: 'insensitive' } },\n        { description: { contains: search, mode: 'insensitive' } },\n        { tags: { has: search } },\n      ];\n    }\n    //Si hay proyecto, busca tecnologías asociadas a ese proyecto\n    if (project) {\n      where.projects = {\n        some: {\n          name: project,\n        },\n      };\n    }\n    //Validamos campos de ordenamiento\n    const validOrderFields = ['name', 'createdAt'];\n    const validOrderTypes = ['asc', 'desc'];\n    //Establece valores seguros para ordenamiento\n    const sortField = validOrderFields.includes(orderBy)\n      ? orderBy\n      : 'createdAt';\n    const sortOrder = validOrderTypes.includes(order) ? order : 'desc';\n\n    const [technologies, total] = await Promise.all([\n      this.prisma.technology.findMany({\n        //Obtiene tecnologías filtradas con relaciones incluidas\n        where,\n        include: {\n          questions: true,\n          resources: true,\n          projects: true,\n        },\n        skip,\n        take,\n        orderBy: {\n          [sortField]: sortOrder,\n        },\n      }),\n      //Cuenta total de registros que cumplen los filtros\n      this.prisma.technology.count({ where }),\n    ]);\n    //Retorna las tecnologías encontradas y el total de registros\n    return { technologies, total };\n  }\n\n  async findOne(id: number): Promise<Technology> {\n    //Buscamos filtrando por id la tecnología\n    const technology = await this.prisma.technology.findUnique({\n      where: { id },\n      include: {\n        questions: true,\n        resources: true,\n        projects: true,\n      },\n    });\n    //Si no existe el id lanzamos el error 404\n    if (!technology) {\n      throw new HttpException(`Technology with ID ${id} not found`, 404);\n    }\n    //Si existe lo retornamos\n    return technology;\n  }\n\n  async update(\n    //Recibe el id por parametro y el DTO de actualización\n    id: number,\n    updateTechnologyDto: UpdateTechnologyDto,\n  ): Promise<Technology> {\n    //Desestructuramos los proyectos recibidos y los datos de las tecnologías\n    const { projects, ...technologyData } = updateTechnologyDto;\n\n    // Verificar si existe la tecnología\n    const existing = await this.prisma.technology.findUnique({\n      where: { id },\n    });\n    //Error por si no existe tecnología con id indicado por parametro\n    if (!existing) {\n      throw new HttpException(`Technology with ID ${id} not found`, 404);\n    }\n\n    // Si se está actualizando el nombre, verificar que no exista otro con ese nombre\n    if (technologyData.name) {\n      const nameExists = await this.prisma.technology.findFirst({\n        where: {\n          name: technologyData.name,\n          id: { not: id },\n        },\n      });\n      //Si el nombre existe, lanzamos el error\n      if (nameExists) {\n        throw new HttpException(\n          `Technology with name ${technologyData.name} already exists`,\n          500,\n        );\n      }\n    }\n\n    try {\n      //Actualizamos los datos\n      return await this.prisma.technology.update({\n        where: { id }, //Filtramos por id\n        data: {\n          ...technologyData, //Enviamos la data desestructurada\n          projects: projects //Enviamos los proyectos\n            ? {\n                set: [], // Desvincula todos los proyectos existentes\n                connect: projects.map((name) => ({ name })), // Conecta los nuevos proyectos\n              }\n            : undefined,\n        },\n        include: {\n          questions: true,\n          resources: true,\n          projects: true,\n        },\n      });\n    } catch (error) {\n      if (error instanceof Prisma.PrismaClientKnownRequestError) {\n        if (error.code === 'P2025') {\n          throw new HttpException('One or more projects not found', 404);\n        }\n      }\n      throw error;\n    }\n  }\n\n  async remove(id: number): Promise<Technology> {\n    // Verificar si existe la tecnología\n    const existing = await this.prisma.technology.findUnique({\n      //Filtramos por id\n      where: { id },\n      include: {\n        questions: true,\n        resources: true,\n        projects: true,\n      },\n    });\n    //Si no existe lanzamos error 404\n    if (!existing) {\n      throw new HttpException(`Technology with ID ${id} not found`, 404);\n    }\n\n    // Verificar si tiene relaciones y eliminarlas si es necesario\n    if (existing.questions.length > 0 || existing.resources.length > 0) {\n      // Eliminar primero las relaciones\n      await this.prisma.$transaction([\n        this.prisma.question.deleteMany({\n          where: { technologyId: id },\n        }),\n        this.prisma.resource.deleteMany({\n          where: { technologyId: id },\n        }),\n      ]);\n    }\n\n    // Eliminar la tecnología\n    return await this.prisma.technology.delete({\n      where: { id },\n      include: {\n        projects: true,\n      },\n    });\n  }\n}\n"
    }
  }
}